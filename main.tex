\documentclass[compress]{beamer}

\usepackage{ctex}

% beamer
\PassOptionsToPackage{subsection=false}{beamerouterthememiniframes}
\setbeamerfont{title}{size=\huge}
\setbeamertemplate{itemize item}{$\bullet$}
\setbeamertemplate{bibliography item}[text]
%gets rid of bottom navigation bars
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{frametitle}{
    \begin{center}
        \insertframetitle
        \par
    \end{center}
}

\usepackage{etoolbox}
\makeatletter
\patchcmd{\slideentry}{\advance\beamer@xpos by1\relax}{}{}{}
\def\beamer@subsectionentry#1#2#3#4#5{\advance\beamer@xpos by1\relax}%
\makeatother

% toc
\AtBeginSection[]{
    \begin{frame}{Outline}
        \begin{columns}
            \begin{column}{0.4\textwidth}
            \end{column}
            \begin{column}{0.6\textwidth}
                \tableofcontents[currentsection, hideallsubsections] 
            \end{column}
        \end{columns}
    \end{frame} 
}

%footnote
\usepackage{url}
\newcommand{\footurl}[1]{\footnote{\url{#1}}}

%code
\input{mint}

% figure
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{caption}
\captionsetup{labelformat=empty,labelsep=none}
\usepackage{subcaption}
\usepackage[multidot]{grffile}

% cross over
\usepackage[normalem]{ulem}

% shorthand
\newcommand{\fname}[1]{\texttt{#1}}

\title{Modern C++ Coding}
\author{answeror@gmail.com}
\date{2013-11-30}

\begin{document}

\frame{\titlepage}

\begin{frame}
    \begin{quote}
        A cynical answer is that many people program in C++, but do not understand and/or use the higher level functionality. Sometimes it is because they are not allowed, but many simply do not try (or even understand).

        As a non-boost example: how many folks use functionality found in \mint{c}/<algorithm>/?

        In other words, \textcolor{red}{many C++ programmers are simply C programmers using C++ compilers}, and perhaps \mint{c}/std::vector/ and \mint{c}/std::list/. That is one reason why the use of \mint{c}/boost::tuple/ is not more common.\footnote{\url{http://stackoverflow.com/a/855478}}
    \end{quote}
\end{frame}

\section{内存管理}

\begin{frame}
    \begin{quote}
        C++ is the best language for garbage collection principally because it creates less garbage.
    \end{quote}
    \vskip5mm
    \hspace*\fill{\small--- Bjarne Stroustrup}
\end{frame}

\newcommand{\smartpointer}{智能指针(smart pointer)}
\subsection{\smartpointer}

\begin{frame}{\smartpointer}
    \begin{center}
        \large less pointer\pause
        
        less new\pause

        never \textcolor{red}{delete}
    \end{center}
\end{frame}

\begin{frame}{\smartpointer}
    \begin{itemize}[<+->]
        \item 共享所有权, 共享使用权: \mint{c}/shared_ptr/
        \item 独占所有权, 独占使用权: \mint{c}/unique_ptr/, \mint{c}/boost::scoped_ptr/
        \item 没有所有权, 具有使用权: 引用\footnote{良好初始化和管理的裸指针被广泛使用, 但不建议新手使用.}, \mint{c}/ref/, \mint{c}/boost::optional/
    \end{itemize}
    \vskip5mm
    \onslide<4->{
        \begin{center}
            共享权指生命周期的控制, 使用权指可拷贝性.
        \end{center}
    }
\end{frame}

\begin{frame}[fragile]{共享所有权, 共享使用权}
    \begin{minted}[fontsize=\footnotesize]{c}
std::shared_ptr<model> load_model(const std::string &path);
...
auto m = load_model("learnt-model.xml");
output_model_info(m);
algo1.set_model(m);
algo2.set_model(m);
    \end{minted}
    \vskip5mm
    Python, Java等语言里的绝大多数变量均共享所有权和使用权. 对应到C++里一般都可以用\mint{c}/shared_ptr/处理. 原则上被共享的类型最好是不可变的, 即仅包含\textcolor{red}{const} public成员.
\end{frame}

\begin{frame}[fragile]{独占所有权, 独占使用权}
    \begin{minted}[fontsize=\footnotesize]{c}
{
    typedef some_large_class_not_sutable_on_stack type;
    boost::scoped_ptr<type> foo(new type);
    // use foo
}
// foo being released automatically
    \end{minted}
    \vskip5mm
    在\textcolor{red}{任何}情况下, 都应优先使用独占所有权和使用权的智能指针. 因为共享通常意味着可控性的降低, 意味着更多的bug.
\end{frame}

\begin{frame}[fragile]{没有所有权, 具有使用权}
    \begin{minted}[fontsize=\footnotesize]{c}
struct wrapper {
    const foo &base;
    wrapper(const foo &base) : base(base) {}
    std::string name() const {
        return "wrapped" + base.name()
    }
};
    \end{minted}
    \vskip5mm
    托管生命周期的共享是C++内存管理的精髓. 引用和ref都是为了减少裸指针的误用而存在的. boost库本身极少使用\mint{c}/shared_ptr/, 而是把对象生命周期托管给库的使用者.
\end{frame}

\begin{frame}[fragile]{没有所有权, 具有使用权}
    \begin{minted}[fontsize=\footnotesize]{c}
using boost::irange;
using boost::adaptors::filtered;

auto even = irange<int>(0, 10) | filtered([](int x){
    return x & 1 == 0;
});
    \end{minted}
    \vskip5mm
    内存管理责任的移交意味着高效和易错. 上述代码中\mint{c}/even/区间在构造完毕时就已经失效了.
\end{frame}

\newcommand{\handle}{句柄(handle)}
\subsection{\handle}

\begin{frame}{\handle\footnote{参见Accelerated C++, 不要与操作系统里的(文件, 窗口等)句柄混淆.}}
    \begin{center}
        \large less \mint{c}/shared_ptr/
    \end{center}
\end{frame}

\begin{frame}{句柄的两种用途}
    \begin{columns}
        \begin{column}{0.2\textwidth}
        \end{column}
        \begin{column}{0.8\textwidth}
            \begin{itemize}[<+->]
                \item 隐藏实现.
                \item 将(共享)语义与类型关联.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{例子}
    \inputminted[fontsize=\footnotesize]{c}{qda.hpp}
\end{frame}

\begin{frame}
    \inputminted[fontsize=\footnotesize]{c}{qda_impl.cpp}
\end{frame}

\begin{frame}
    \inputminted[fontsize=\footnotesize]{c}{use_qda.cpp}
    \vskip5mm
    用户不必关心使用哪种智能指针来保存qda, 同时QDA的设计者可以决定类型的共享语义, 避免误用.

    用户只需要知道类型的(值/共享)语义, 可以用同一套语法来操作其对象(使用点号调用成员, 而不是指针的箭头符号).

    对于值语义的对象, 比如\mint{c}/X/, 可以通过\mint{c}/std::move/避免数据拷贝\footnote{但仍需要指针拷贝}.
\end{frame}

\section{抽象}

\begin{frame}{一切皆为抽象}
    \begin{itemize}[<+->]
        \item 编程语言和数学系统的核心皆为抽象.
        \item 变量, 函数, OOP都是针对各自领域问题的抽象手段.
        \item OOP经常在不合适的领域被\textcolor{red}{极度}滥用.
    \end{itemize}
\end{frame}

\subsection{函数}

\begin{frame}{函数}
    \begin{itemize}[<+->]
        \item 在科学计算领域, 函数是最好的抽象手段.\footnote{个人认为}
        \item (纯)函数\footnote{pure function}易于描述(输入, 输出, 前条件, 后条件).
        \item (纯)函数易于测试.
    \end{itemize}
\end{frame}

\begin{frame}{编码过程}
    \begin{enumerate}[<+->]
        \item 首先明确问题(函数)的输入输出.
        \item 构造数据, 写针对函数的单元测试.
        \item 分解主函数为多个子函数, 写子函数的单元测试.
        \item 子函数之间通过函数参数传递状态.
        \item 若函数参数列表太长\footnote{大于7, 参见代码大全.}, 则将共享参数的函数打包成类.
    \end{enumerate}
\end{frame}

\subsection{template}

\begin{frame}{template}
    \begin{itemize}[<+->]
        \item duck typing: If it looks like a duck and quacks like a duck, it's a duck.
        \item C++模板提供了编译期的duck typing手段.
    \end{itemize}
\end{frame}

\begin{frame}{duck typing in Python}
    \inputminted[fontsize=\footnotesize]{python}{mean.py}
\end{frame}

\begin{frame}{duck typing in C++}
    \inputminted[fontsize=\footnotesize]{c}{mean.cpp}
\end{frame}

\begin{frame}{duck typing in C++}
    \inputminted[fontsize=\footnotesize]{c}{use_mean.cpp}
\end{frame}

\newcommand{\typeerase}{类型擦除(type erase)}
\subsection{\typeerase}

\begin{frame}{\typeerase}
    \begin{itemize}[<+->]
        \item 有时候模板带来的编译负担太重\footnote{还有源码保密等因素}, 需要借助虚函数减少代码生成.
        \item 但是我们通常需要组合式的接口(例如sum, size), 使用OOP会造成组合爆炸以及侵入式继承体系.
    \end{itemize}
\end{frame}

\subsection{function}

\begin{frame}{C style optimization}
    \inputminted[fontsize=\footnotesize]{c}{optimize.h}
    \vskip5mm
    \pause
    \begin{itemize}[<+->]
        \item 只能传递函数指针
        \item 容易诱使全局变量产生
        \item 难以并行化
        \item 解决办法一般是在f签名中增加表示数据的void指针
    \end{itemize}
\end{frame}

\begin{frame}{old and bad C++ style optimization}
    \inputminted[fontsize=\footnotesize]{c}{old_optimize.hpp}
    \vskip5mm
    \pause
    \begin{itemize}[<+->]
        \item 侵入式, 要求继承\mint{c}/fn/.
        \item 代码长(Keep it simple, stupid!).
    \end{itemize}
\end{frame}

\begin{frame}{template C++ style optimization}
    \inputminted[fontsize=\footnotesize]{c}{template_optimize.hpp}
    \vskip5mm
    \pause
    \begin{itemize}[<+->]
        \item 所有实现必须写在头文件里, 编译慢.
        \item 源码泄漏.
    \end{itemize}
\end{frame}

\begin{frame}{modern C++ style optimization}
    \inputminted[fontsize=\footnotesize]{c}{modern_optimize.hpp}
\end{frame}

%\subsection{range}

\subsection{Boost.TypeErasure}

\begin{frame}{the core of type erase}
    \inputminted[fontsize=\footnotesize]{c}{core_te.hpp}
\end{frame}

\begin{frame}{the core of type erase}
    \inputminted[fontsize=\footnotesize]{c}{use_core_te.hpp}
\end{frame}

\begin{frame}{Boost.TypeErasure}
    \inputminted[fontsize=\footnotesize]{c}{boost_te.hpp}
    \vskip5mm
    Boost.TypeErasure提供了组合接口的各种组件. 上面的classifier与之前手工定义的classifier效果完全一样.
\end{frame}

\begin{frame}
    \begin{center}
        \huge{Thanks}
    \end{center}
\end{frame}

\end{document}
